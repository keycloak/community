# Healthcheck endpoint

* **Status**: Draft #1
* **JIRA**: [KEYCLOAK-12398](https://issues.redhat.com/browse/KEYCLOAK-12398)
* **Observability JIRA**: [KEYCLOAK-8288](https://issues.jboss.org/browse/KEYCLOAK-8288)

## Motivation

Deploying both Keycloak and RHSSO on top of Kubernetes requires defining both Readiness Check and Liveness Check
(see the [manual](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)).
Currently, for Keycloak we use a very naive implementation, that calls `/auth/realms/master` URL.
One of the biggest disadvantages of this approach is that it doesn't check the database state. The newly designed
Healthcheck API presented in this design will address this problem.

## Scope

The scope of this Design includes:
- Healthcheck API design
- Implementation suggestions

This design targets Quarkus-based distribution as a main target runtime.

After many discussions, we decided to remove from the initial design the following items:
- Wildfly-based deployments. We decided to use whatever we have for the RHSSO implementation and focus
on the future - on Keycloak.x.
- External IdP and User Federation checks. Including any of those checks makes the end-user situation worse.
If we include an External IdP check in the Health endpoint, Kubernetes will plug all the pods out of the Service
(a load balancer) if that IdP is down. Once all pods are removed from the Service, an end-user will see an HTTP 503
Error page generated by the OpenShift router. If however, the External IdP is down, and we don't include it in the
Health endpoint, a user will probably face an error during log in. But the error page will be displayed by Keycloak,
and we control what message we send there. I consider this as a slightly better situation, although the end-result is
the same - a user cannot log in.
- Parametrized checks, e.g. `http://localhost:8080/auth/health?timeout=2s&fail-on=db,idp-google`. After removing
the External IdPs and User Federation, the parametrized check is no longer necessary. Perhaps, we'll get back
to it in the future.

## Healthcheck endpoint

The new Healthcheck endpoint will contain two checks - Liveness and Readiness:

    http://localhost:8080/health/ready
    http://localhost:8080/health/live

## Active vs Passive checks

From the implementation perspective, there are two ways of implementing Healthcheck calls within Keycloak:
* Active - whenever we check if a database is down (this is just an example), we initiate a new connection and
check if it succeeds.
* Passive - we position the implementation based on Metrics components (see the Observability Design). We actively
analyze database connection metrics reported by JCA subsystem
(see [the currently available metrics in Keycloak](https://docs.google.com/spreadsheets/d/1YGn4wwUupgQsFTmlm-5VXgLYkigTdy_TEnDhqFxNXXo/edit#gid=0))
and if we discover  increasing failure count, we report an at Health Endpoint as well.

The former approach seems more natural but has a lof of drawbacks, including:
* Additional connections allocated in the thread pools.
* Often requires integrating with additional subsystems (e.g. JCA for database checks).
* Complicated to ensure that `timeout` parameter is properly respected.

All the above pain points are not applicable for the Passive Mode. Essentially, all database, User Federation LDAP servers
and External IdPs probes are free of charge as we report success/failure calls for them in the Metrics components.
With this approach, the Healthcheck Endpoint becomes an alternative reporting tool for the Metrics.

This design assumes implementing Health Endpoint in Passive Mode (with possible elements of active checks).

#### Microprofile Health

[Eclipse Microprofile Health](https://download.eclipse.org/microprofile/microprofile-health-3.0-RC4/microprofile-health-spec.html)
project provides capabilities for reporting Liveness and Readiness probes. In the contrast to Microprofile Metrics,
the Health project doesn't provide a centralized class to access all configured checks. The SmallRye implementation
provides `SmallRyeHealthReporter` (see [the code](https://github.com/smallrye/smallrye-health/blob/73e9ea8c31498dab7753f4a428cb424bf9fbaa1a/implementation/src/main/java/io/smallrye/health/SmallRyeHealthReporter.java#L49))
, that is a CDI-annotated Bean that contains references to `HealthCheck` implementations. The `HealthCheck` interface
implementations provides a specific check - e.g. check if a database is up.

Keycloak will provide either its own implementation of a class similar to `SmallRyeHealthReporter`, or
a CDI-annotated bean that will be used as a bridge between Microprofile Health, and the rest of the Keycloak code. The
latter solution is preferred as the out-of-the-box support has been already implemented in Quarkus.

Individual Healthcheck implementations, such as database check, External IdP check or LDAP check need to be provided
as `HealthCheck` class implementations.

#### Database check

Agroal (the lightweight database connection pool) publishes a set of metrics into the main Quarkus Metrics Registry
(see [the code](https://github.com/quarkusio/quarkus/blob/master/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/metrics/AgroalMetricsRecorder.java#L37-L113)).
It also provides an active healthcheck (see [the code](https://github.com/quarkusio/quarkus/blob/master/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/health/DataSourceHealthCheck.java)).

The goal of the implementation is to provide a specialized check that is a hybrid between an active and a passive mode.
When Keycloak is serving traffic, the implementation needs to track the database health by observing metrics reported
by the Agroal framework. However, when Keycloak is idle, the implementation needs to either ask Agroal to maintain at least
one, healthy connection or perform an active check.

#### Healthcheck API for Liveness and Readiness probes

The REST response has been defined in [Microprofile Health Spec](https://download.eclipse.org/microprofile/microprofile-health-3.0-RC4/microprofile-health-spec.html#_appendix_a_rest_interfaces_specifications).
There are 3 possible HTTP Status codes that might be returned from the endpoint:
* 200 - Healthcheck passes
* 500 - An exception is thrown in the probe's code
* 503 - Healthcheck fails (reports status DOWN)

The REST response body contains additional information helpful for debugging. A non-ready response call for
`http://<keycloak-url>:8080/health` might look like the following:

```json
{
  "status": "DOWN",
  "checks": [
    {
      "name": "org.keycloak.health.DatabaseCheck",
      "status": "DOWN",
      "data": {
        "failingTime": "failing for 30s",
        "cause": "Exception message from the JDBC Driver or Agroal"
      }
    }
  ]
}
```

## Deliverables

In order to implement the Health Endpoint, at least a basic version of the Metrics Component (see the Observability
Design) needs to be in place.

Deliverables and timeframe:
* Rough timeframe - 1 or 2 sprints for a team
* Basic Health Endpoint that works on Quarkus
* Database checks

## Resources

* [Observability ticket](https://issues.jboss.org/browse/KEYCLOAK-8288)
* [Microprofile Health Spec](https://download.eclipse.org/microprofile/microprofile-health-3.0-RC4/microprofile-health-spec.html)
* [SmallRye Health Groups](https://xstefank.io/2020/04/21/health-groups-experimental-microprofile-health-extension-in-quarkus/)

